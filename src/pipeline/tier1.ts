import type { TierResult, VideoMetadata, Ingredient } from "../types.js";
import { fetchTranscript, joinTranscript } from "../services/youtube.js";
import { extractIngredients } from "../services/gemini.js";
import { rawToIngredients } from "./normalizer.js";

/**
 * Tier 1 — Transcript + LLM Extraction
 *
 * 1. Fetch YouTube captions (manual or auto-generated)
 * 2. Send full transcript to Gemini for ingredient extraction
 * 3. Score confidence based on caption quality and result count
 */
export async function runTier1(
  metadata: VideoMetadata,
  previousIngredients: Ingredient[]
): Promise<TierResult> {
  // --- Step 1: Fetch transcript ---
  let transcriptText: string;
  let isAutoGenerated = true;

  try {
    const segments = await fetchTranscript(metadata.video_id);
    if (segments.length === 0) {
      return noTranscriptResult();
    }
    transcriptText = joinTranscript(segments);
    // youtube-transcript doesn't distinguish manual vs auto — assume auto
    // unless the text quality is high (heuristic: few "[Music]" markers)
    const musicMarkers = (transcriptText.match(/\[music\]/gi) || []).length;
    isAutoGenerated = musicMarkers > 2;
  } catch {
    return noTranscriptResult();
  }

  // --- Step 2: Send to LLM ---
  // Truncate very long transcripts to avoid hitting token limits
  const maxChars = 30_000; // ~7.5K tokens
  const truncated =
    transcriptText.length > maxChars
      ? transcriptText.slice(0, maxChars) + "\n[transcript truncated]"
      : transcriptText;

  const extracted = await extractIngredients(truncated, "transcript");
  const cost = 0.001; // ~7K input + 200 output tokens at $0.10/1M

  const ingredients = rawToIngredients(extracted.ingredients);

  // --- Step 3: Merge with previous tier data ---
  const merged = mergeIngredients(previousIngredients, ingredients);

  // --- Step 4: Confidence scoring ---
  let confidence: number;
  if (!isAutoGenerated && merged.length >= 5) {
    confidence = 0.9;
  } else if (merged.length >= 5) {
    confidence = 0.8;
  } else if (merged.length >= 3) {
    confidence = 0.65;
  } else if (merged.length >= 1) {
    confidence = 0.5;
  } else {
    confidence = 0.2;
  }

  return {
    tier: 1,
    confidence,
    ingredients: merged,
    servings: extracted.servings,
    source_urls: [],
    cost_usd: cost,
    recipe_name: extracted.recipe_name,
  };
}

function noTranscriptResult(): TierResult {
  return {
    tier: 1,
    confidence: 0,
    ingredients: [],
    servings: null,
    source_urls: [],
    cost_usd: 0,
    recipe_name: null,
  };
}

/**
 * Merge ingredients from two tiers, deduplicating by name similarity.
 */
function mergeIngredients(
  existing: Ingredient[],
  incoming: Ingredient[]
): Ingredient[] {
  const merged = [...existing];
  const existingNames = new Set(
    existing.map((i) => i.name.toLowerCase().trim())
  );

  for (const ingredient of incoming) {
    const name = ingredient.name.toLowerCase().trim();
    if (!existingNames.has(name)) {
      merged.push(ingredient);
      existingNames.add(name);
    }
  }

  return merged;
}
